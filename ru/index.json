[{"url":"https://d0sl.org/ru/getting-started/chess/sample/","title":"Подробности проекта","description":"","content":"Чтобы запустить пример с шахматами  Найдите семантическую модель ChessAII в org.d0sl.examples/sandbox. Откройте на ней контекстное меню, нажав правую кнопку мыши. И выберите Run Node ChessAII.  Чтобы изменить семантику Семантическая модель определена в песочнице/ChessAII. Когда робот расставляет ферзей, он вызывает предикат check board. В семантической модели заранее подготовлено несколько различных предикатов check board. Просто измените имя текущего предиката check board, а другой (например, check board1 переименуйте в check board. И вы увидите, как меняется поведение робота в зависимости от заданной семантики.\nНапример, следующая модель запретит роботу ставить ферзей на одну линию, но он сможет расположить их по одной диагонали.\ndef check board2(board : ChessBoard) means  check all  var queens = ChessDSL.get queens(board)  for all q1, q2 in queens  not ChessDSL.on one line(q1, q2)  end end def  После каждого изменения модели не забывайте пересобирать решение MPS (Ctrl+F9).\n Java-часть Java-часть примера можно найти в org.d0sl.examples/chess\n Прежде всего, обратите внимание на класс ChessDSL, который, используя аннотации, указывает на специфические для домена функции, на которые мы ссылаемся в нашей семантической модели. Например\n /** Represents a DSL for task: Arrangement of chess queens */  @DomainModel(name = \u0026#34;ChessDSL\u0026#34;) public class ChessDSL {  \u0026lt;...SKIPPED...\u0026gt;  /** Check if two queens are in the same horizontal or vertical @param @return */  @DomainFunction(name = \u0026#34;on one line\u0026#34;)  public boolean onOneLine(ChessQueen q1, ChessQueen q2) {  if (q1.getCol() == q2.getCol() || q1.getRaw() == q2.getRaw()) { return true; }  return false;  }  /** Check if two queens are in the same diagonal @param @return */  @DomainFunction(name = \u0026#34;on one diagonal\u0026#34;)  public boolean onOneDiagonal(ChessQueen q1, ChessQueen q2) {  if (Math.abs(q1.getCol() - q2.getCol()) == Math.abs(q1.getRaw() - q2.getRaw())) { return true; }  return false;  } } После этого, в нашей семантической модели, мы можем указать, в каком классе можно найти реализацию предикатов on one line и on one diagonal.\nuse ChessDSL from org.d0sl.examples.chess.ChessDSL Также в классе ChessRobot можно найти, как робот вызывает предикат check board из семантической модели.\ntry {  board.getBoard().setPieces(pieces);  LogicalConstant check = semantic.callPredicate(\u0026#34;check board\u0026#34;, board);  if (check.getValue() != Logical.TRUE) {  pieces[i][j] = null;  board.getBoard().setPieces(pieces);  } else {  boardPanel.setPiece(pieces[i][j], visit);  boardPanel.refreshUI();  if (queenNumber == 7) {  return true;  } else {  if (arrange(pieces, new LinkedList(), queenNumber + 1)) {  return true;  } else {  pieces[i][j] = null;  board.getBoard().setPieces(pieces);  boardPanel.clear(visit);  boardPanel.refreshUI();  }  }  } } catch (SemanticException e) {  e.printStackTrace(); }  Алгоритм следующий: робот ставит следующего ферзя и спрашивает, все ли хорошо. Если ответ положительный, то робот пытается поставить следующего ферзя, а если ответ отрицательный, то робот убирает последнего ферзя и ищет для него другую клетку. Если возникает ситуация, когда невозможно поставить следующего ферзя ни на одну клетку, робот возвращается на шаг назад, отсекая плохое поле.\n "},{"url":"https://d0sl.org/ru/d0sl-language/root/","title":"Семантическая и доменная модели","description":"","content":"В d0sl есть два вида корневых документов — семантическая модель и модель предметной области.\nСемантическая модель предназначена для определения семантических предикатов и позволяет пользователям определять логические правила.\nМодель, специфичная для предметной области, определяет объекты и функции, которые можно использовать в семантической модели, но они специфичны для области предметной области. Это похоже на заголовочный файл C.\nЧтобы создать семантическую или доменную модель, откройте контекстное меню, щелкнув правой кнопкой мыши на sandbox, а затем выберите new/SemanticLanguage/DomainSpecificModel или new/SemanticLanguage/SemanticModel.\nПример Semantic Model model ChessAII def  use ChessDSL from org.d0sl.examples.chess.ChessDSL   def start() means  check all  ChessDSL.start()  end  end def    def check board(board : ChessBoard) means  check all  var queens = ChessDSL.get queens(board)  for all q1, q2 in queens  not ChessDSL.on one line(q1, q2) and  not ChessDSL.on one diagonal(q1, q2)  end  end def   end def  end ChessAII Пример Domain Model domain specific model Math def  # Math library   # Square root  fun sqrt(value : numeric) returns numeric   # Sinus and Cosinus  fun sin(value : numeric) returns numeric  fun cos(value : numeric) returns numeric   # Power function  fun pow(value : numeric, power : numeric) returns numeric end Math "},{"url":"https://d0sl.org/ru/getting-started/requirements/","title":"Требования","description":"","content":"Итак, наша главная цель - дать человеку возможность описывать логические правила на понятном языке. Мы называем его d0sl или Delta Zero Semantic Language.\nДля этого нам необходимо реализовать язык, а также предоставить удобный редактор (или IDE Integrated Development Environment), который позволил бы создавать документы d0sl и даже сразу запускать.\nСуществуют различные способы достижения этой цели, но мы выбрали в качестве основы мощную систему программирования Jetbrains MPS (Meta Programming System).\nНаши примеры работают с версией MPS 2021.3, поэтому вы должны сначала установить ее из здесь. Пожалуйста, будьте внимательны и выбирайте версию 2021.3 для ОС вашего компьютера.\n Мы выбираем MPS, потому что:\n  MPS IDE очень похожа на Intelliji Idea, PyCharm и другие продукты Jetbrains. MPS помогает создавать мощные DSL (предметно-ориентированные языки). С помощью MPS мы можем создавать плагины языка d0sl для Intelliji Idea. Мы смогли разработать технологию, которая не зависит от MPS и может использоваться отдельно. Но мы не видим причин отказываться от удобства MPS там, где это возможно.   "},{"url":"https://d0sl.org/ru/vision/problems/","title":"Проблемы алгоритмического подхода","description":"","content":"Теория алгоритмов была создана Аланом Тьюрингом в рамках усилий союзников во время Второй мировой войны по взлому нацистского кода Enigma с помощью так называемых компьютеров. Компьютеры могут понимать только точные наборы инструкций, объясняющих, как решить задачу. Такие наборы инструкций называются алгоритмами компьютерных программ.\nНо мы, люди, в повседневной жизни используем логику в своем языке. Обычный человек вряд ли сможет запомнить все инструкции даже к стиральной машине. Поэтому у нас есть специальные люди, которые могут делать перевод между нами, людьми, и компьютерами, их называют разработчиками программного обеспечения или программистами. Но проблема в том, что даже после более чем 70-летней истории компьютеров у нас осталось менее 1% населения, способных выполнять такую работу.\nАлгоритмы* дают компьютерам точный набор инструкций о том, как решить проблему. Для того чтобы создать такой *алгоритм_, необходимо выполнить определенные шаги:\n Задать проблему таким образом, чтобы исключить неопределенность. Такие спецификации должны иметь жесткую и логическую форму. Поручить ее программистам. В конечном итоге после нескольких технологических этапов (таких как архитектура, ОО проектирование и т.д.) программисты преобразуют спецификацию в программу, написанную на одном из языков программирования. Теперь такая программа может быть переведена в машинный код и выполнена на компьютере.  Это означает, что каждый раз, когда нам нужно заставить компьютеры что-то делать, мы должны иметь компьютерную программу, которая может быть создана только разработчиками программного обеспечения ручно. Ручная работа, как всем известно, подразумевает человеческие ошибки. Поэтому №1 проблема - это качество программ, написанных людьми. Программные жучки могут убить любое хорошее намерение.\nЧем больше программ нам нужно, тем больше разработчиков программного обеспечения будет задействовано. Чем больше компьютеров будет использоваться человечеством, тем больше программ нам понадобится, и тем больше разработчиков потребуется. Внедрение мобильных телефонов, IoT и Edge Computing в повседневную жизнь создает все больший спрос на программистов. Не забывайте, что каждый мобильный телефон - это компьютер. И мы хотим установить компьютерные чипы в такие вещи, как чайники и холодильники.\nСегодня на планете больше компьютеров, чем людей. Подумайте об этом. Где мы возьмем достаточно разработчиков программного обеспечения в ситуации, когда количество компьютеризированного оборудования растет гораздо быстрее, чем количество разработчиков. Это проблема №2 - у нас не хватает программистов.\nА проблема №3 - в том, что мобильные коммуникации, роботы, edge computing и Iot повторяют проблему качества: наша цивилизация становится все более и более зависимой от качества компьютерных программ.\n"},{"url":"https://d0sl.org/ru/getting-started/installation/","title":"Установка","description":"","content":" Установите систему программирования Jetbrains Meta Programming System (MPS) https://www.jetbrains.com/mps/. Клонируйте git-репо: git clone https://github.com/d0sl/d0SDK  При первом запуске MPS отображает окно выбора проекта. Но сначала вы выбираете шестеренку в нижней части Configure/plugins.  Затем выберите установить плагин с диска.  Затем выберите файл d0SDK/plugin/0.8.9.2/d0sl-plugin-mps.zip  После установки плагина вы должны увидеть следующее:  Откройте проект в MPS, выбрав клонированную директорию (например, директорию d0SDK). Пересоберите проект  Если все прошло успешно, вы увидите следующее окно:   "},{"url":"https://d0sl.org/ru/getting-started/chess/","title":"Задача о 8 ферзях","description":"","content":"Головоломка восьми ферзей Головоломка восьми ферзей - это проблема размещения восьми шахматных ферзей на шахматной доске 8×8 так, чтобы никакие два ферзя не угрожали друг другу.\nПроблема поиска всех решений задачи о восьми ферзях может быть достаточно вычислительно затратной, поскольку существует 4 426 165 368 возможных расположений восьми ферзей на доске 8×8, но только 92 решения.\n Семантический способ решения этой проблемы заключается в следующем:\n Представьте, что у нас есть робот, который может произвольно расставить восемь ферзей на шахматной доске. Но он не знает, правильная это позиция или нет. Затем, после каждой расстановки, робот спрашивает нас, правильно ли он расположил ферзей на доске. Если мы отвечаем, что правильно, робот считает задание выполненным. Если же мы говорим, что неправильно, робот пытается расположить ферзей по-другому. Для того чтобы определить, правильно ли расставлены ферзи на шахматной доске, мы напишем семантические правила на языке d0sl. Например: Для любых двух ферзей на шахматной доске должно быть верно, что они не находятся на одной диагонали и не находятся на одной линии.  def check board(board : ChessBoard) means  check all  var queens = ChessDSL.get queens(board)  for all q1, q2 in queens  not ChessDSL.on one line(q1, q2) and  not ChessDSL.on one diagonal(q1, q2)  end end def  Далее мы покажем, как запустить пример и посмотреть код.\n "},{"url":"https://d0sl.org/ru/d0sl-language/predicate/","title":"Предикаты","description":"","content":"В математической логике под предикатом принято понимать булевозначную функцию. Однако мы используем расширенное понятие логического типа вместо булевского. И предикат может возвращать три значения: true, false и none (undefined).\nЕсли предикат возвращает none, вы должны рассматривать это как исключение. Например, произошел тайм-аут. none означает, что предикат не смог вычислить true или false.\n Чтобы создать предикат в семантической модели, необходимо набрать ключевое слово def. Затем появляется шаблон предиката. И вы можете указать имя предиката, его аргументы и тело предиката, которое является логическим выражением.\nИмя предиката может содержать пробелы. Также вы можете использовать не только латиницу, но и другие национальные алфавиты \u0026hellip;\n Шаблон предиката создается без аргументов. Чтобы добавить аргумент, поместите курсор внутрь круглых скобок и нажмите Enter или Insert.\n Тело предиката может быть любым логическим выражением языка d0sl: and, or, not, check all, if, for all. Но для простоты мы советуем начинать тело предиката с инструкции check all. Инструкция check all эквивалентна инструкции and с большим количеством аргументов, каждый из которых находится в новой строке.\n Пример определения предиката def check board(board : ChessBoard) means  check all  var queens = ChessDSL.get queens(board)  for all q1, q2 in queens  not ChessDSL.on one line(q1, q2) and  not ChessDSL.on one diagonal(q1, q2)  end end def "},{"url":"https://d0sl.org/ru/d0sl-language/logical/","title":"Логические операции","description":"","content":"   Operation Alias True value False value     and and true and true false and true   or or true or false false or false   not not not false not true   check all check check all true check all false    Инструкция check all эквивалентна инструкции and с большим количеством аргументов, каждый из которых находится в новой строке. Вы можете использовать псевдоним check для ввода инструкции check all.\nНапример, следующие выражения эквивалентны.\nA and B and C and D check all A B C D end check "},{"url":"https://d0sl.org/ru/vision/semantic_tech/","title":"Семантические технологии","description":"","content":"Семантическое моделирование - это технология, которая помогает решать проблемы алгоритмического подхода и работает следующим образом:\n Разработчик или эксперт предметной области создает спецификацию логики приложения (семантическую модель) на языке d0SL в IDE d0SDK. Затем d0SDK генерирует java код этой семантической модели. Теперь java-код этой семантической модели может быть выполнен на d0VM (виртуальной машине дельта 0).  "},{"url":"https://d0sl.org/ru/d0sl-language/if/","title":"If (импликация)","description":"","content":"Импликация как конструкция if в d0sl является false только тогда, когда условие является true, а часть then является false. Другими словами, импликация if(A) then B является сокращенной записью выражения not(A) or B.\nИспользуйте ключевое слово if, и редактор предоставит вам шаблон для конструкции if.\n Пример "},{"url":"https://d0sl.org/ru/d0sl-language/for/","title":"For all (Для каждого)","description":"","content":"Чтобы создать логическое выражение for all, необходимо ввести ключевое слово for. После этого появится шаблон for all.\nОбщая форма этого логического выражения следующая for all x1, x2... xn in listX Expression(x1,...,xn). Это означает, что для каждого \u0026lt;x1,..,xn\u0026gt; из списка listX выражение Expression(x1, ..., xn) должно быть истинным (true).\nПример Для вычисления результата производится выбор различных комбинаций \u0026lt;x1...xn\u0026gt; из некоторого списка. Если такой выбор сделать невозможно, считается, что формула не была вычислена, и выражение for all возвращает true. То есть, если список пуст или имеет меньшую размерность, чем вектор \u0026lt;x1...xn\u0026gt;, то в итоге будет получено true, однако формула внутри for all не будет вычислена.\n "},{"url":"https://d0sl.org/ru/vision/apps/","title":"Применение","description":"","content":"\u0026hellip; и примеры использования Пожалуйста, не обольщайтесь, семантическое моделирование - это не серебряная пуля. Оно не позволит создать любую программу для не программистов. Семантическое моделирование помогает решать так называемые логические или дискретные проблемы. Например, если вам нужно решить какие-то специфические тяжелые вычислительные задачи (например, нейронные сети, дифференциальные уравнения и т.д.), вам все равно придется заниматься традиционным программированием. Пользовательский интерфейс по-прежнему легче разрабатывается человеком.\nМы видим следующие области применения семантического моделирования:\n Автономные системы. Например, семантическое моделирование уже много лет используется мобильными операторами связи и банками. Бизнес-логика и автоматизация процессов рабочего потока. Встраиваемые системы и edge computing. Промышленный IoT. Робототехника и автономное оборудование  "},{"url":"https://d0sl.org/ru/vision/contract/","title":"Пример цифрового контракта","description":"","content":"Цифровой двойник контракта var номер_договора = \u0026#34;34/1\u0026#34; var место = \u0026#34;г. Новосибирск\u0026#34; var дата = \u0026#34;01.02.2020\u0026#34; var исполнитель = \u0026#34;Вычислительные системы\u0026#34; var заказчик = \u0026#34;Контрагент 123\u0026#34; ДОГОВОР N 34/1 На разработку программного обеспечения и передачу исключительных прав г. Новосибирск\n1 февраля 2020 года\nОбщество с ограниченной ответственностью Научно-производственная компания «Вычислительные Системы», именуемое далее «Исполнитель», в лице Директора Караванова Павла Владимировича, действующего на основании Устава, с одной стороны, и ООО Арс, именуемое далее «Заказчик», в лице Генерального директора Сидорова Георгия Ивановича, действующего на основании Устава, с другой стороны, по отдельности именуемые «Сторона», совместно именуемые «Стороны», заключили настоящий Договор о нижеследующем:\nvar продукт = \u0026#34;Система мониторинга СМС-центра\u0026#34; 1 Термины и определения\n1.1 Программное обеспечение – Программа для ЭВМ Система мониторинга СМС-центра в соответствии с Техническим заданием Заказчика, приведенным в Приложении 1 к настоящему Договору.\n1.2 Оборудование – компьютерное оборудование Заказчика или третей стороны, предназначенное для инсталляции и функционирования на нем Программного обеспечения.\n1.3 Документация – техническая и иная документированная по Программному обеспечению в печатном либо электронном виде.\nvar начало_работ = дата + 5 рабочих дней var дата_окончания = 01.06.2020 2 Предмет договора\n2.1. В силу настоящего договора Исполнитель по заданию Заказчика обязуется разработать Программное обеспечение в соответствии с Техническим заданием Заказчика (далее – «Программное обеспечение»).\n2.2. Исполнитель обязуется передать Заказчику исключительные права на Программные обеспечения. Исключительные права на Программное обеспечение передаются Заказчику с момента подписания сторонами Акта приемки-передачи Программного обеспечения и исключительных прав на Программное обеспечение.\n2.3. Заказчик, в свою очередь, обязуется принять Программное обеспечение, исключительные права на Программное обеспечение, Документацию иные результаты Работ Исполнителя в порядке и в сроки, обусловленные настоящим Договором, а также уплатить Исполнителю вознаграждение, обусловленное настоящим Договором.\n2.4. Дата начала выполнения Работ по настоящему Договору – в течении 5 (Пяти) рабочих дней с даты подписания настоящего Договора\n2.5. Дата окончания Работ, передачи исключительных прав на Программное обеспечение, окончания оказания Услуг – не позднее 01.06.2020.\n2.6. В случае внесения Заказчиком изменений в Техническое задание цена настоящего Договора и сроки исполнения обязательств по нему могут быть изменены Исполнителем.\n3 Цена Договора. Порядок оплаты.\nvar цена_договора = 3 000 000 var аванс = 500 000 var дата_аванса = 15.02.2020 var дата_оплаты = дата_подписания_акта(номер_договора) + 5 рабочих дней 3.1 Цена настоящего Договора составляет 3 000 000 (три миллиона) рублей, НДС не облагается в связи с применением Исполнителем упрощенной системы налогообложения (Глава 26.2 Налогового кодекса РФ).\n3.2 Стоимость Работ по разработке Программного обеспечения по настоящему Договору включает в себя разовый фиксированный платёж за отчуждение исключительных прав на Программное обеспечение.\n3.3 Уплата вознаграждения Исполнителю Заказчиком производится в следующем порядке:\n  500 000 (пятьсот тысяч) рублей, НДС не облагается, Заказчик уплачивает не позднее «15» февраля 2020 года. 2 500 000 (два миллиона пятьсот тысяч) рублей, НДС не облагается, Заказчик уплачивает не позднее 5 (пяти) рабочих дней со дня подписания сторонами Акта приемки-передачи Программного обеспечения и исключительных прав на Программное обеспечение.   3.4. Уплата вознаграждения по настоящему Договору производится платёжными поручениями на расчётный счёт Исполнителя.\nvar дата_согласования_ТЗ = дата + 5 рабочих дней var срок_ответа_на_email = 2 рабочих дня var срок_запуска_автотестов = 2 рабочих дня var срок_проверки_документации = 2 рабочих дня var срок_запуска_приемки = 2 рабочих дня 4 Иные обязанности сторон\n4.1. Исполнитель обязуется:\n 4.1.1. Своевременно и в полном объёме разработать и передать Заказчику Программное обеспечение, передать Заказчику исключительное право на Программное обеспечение, передать Заказчику Документацию, а также выполнить иные Работы и оказать Услуги, предусмотренные настоящим Договором.\n 4.2. Заказчик обязуется:\n 4.2.1. Оказать всё необходимое содействие исполнителю для выполнения его обязательств по настоящему Договору, в том числе, но не ограничиваясь:\n 4.2.1.1. Не позднее 5 (Пяти) рабочих дней с даты подписания настоящего Договора согласовать с Исполнителем окончательный вариант Технического задания.\n4.2.1.2. Предоставить всю имеющуюся документацию на Оборудование и установленное на него программное обеспечение.\n4.2.1.3. Выделить в распоряжение Исполнителя своего технического специалиста, ответственного за взаимодействие с Исполнителем.\n 4.2.2. Предоставлять ответы на запросы исполнителя (электронные письма) по вопросам, связанным с исполнением настоящего Договора, не позднее 2 (Двух) рабочих дней с момента их получения.\n4.2.3. Не позднее 2 (Двух) рабочих дней со дня получения рабочих версий Программного обеспечения, производить их тестирование и предоставлять Исполнителю перечень выявленных недостатков в функционировании Программного обеспечения либо уведомление об их отсутствии.\n4.2.4. Не позднее 2 (Двух) рабочих дней со дня получения рабочих версий Документации, производить их проверку и предоставлять Исполнителю перечень выявленных недостатков в Документации либо уведомление об их отсутствии.\n4.2.5. Не позднее 2 (Двух) рабочих дней после получения соответствующего уведомления от Исполнителя производить приёмку окончательных версий Программного обеспечения, Документации и/или Работ.\n 5 Конфиденциальная информация\n 5.1. Стороны пришли к соглашению, считать конфиденциальной и не подлежащей разглашению (коммерческой тайной) любую информацию, полученную ими по настоящему Договору, включая, но не ограничиваясь: текст настоящего Договора; текст, диаграммы, рисунки любых документов, в том числе технической и коммерческой документации по настоящему Договору; информация о структуре управления любой из Сторон; информация о ценовой и маркетинговой политике любой из сторон; информация о партнёрах и контрагентах Сторон; исходные тексты и исполняемые коды Программного обеспечения; а так же любая иная информация, имеющая пометку «Конфиденциально» и/или «Коммерческая тайна».\n5.2. Каждая из Сторон обязана предпринять адекватные меры по защите конфиденциальной информации, в том числе путём ограничения доступа к ней лиц, непосредственно не связанных с исполнением настоящего Договора. В любом случае меры, предпринимаемые каждой из Сторон по защите Конфиденциальной информации, полученной от другой стороны, должны быть не меньшими, чем предпринимаемые для защиты собственной конфиденциальной информации.\n 6 Ответственность сторон\nvar неустойка_при_задолженности = задолженность * 0.0005 * количество_дней  6.1. При просрочке платежа в соответствии с условиями настоящего Договора и заключаемых в соответствии с ним Дополнительных соглашений, Исполнитель вправе требовать от Заказчика уплаты неустойки из расчёта 0,05 (Ноль целых пять сотых) процента от суммы Задолженности за каждый день просрочки.\n6.2. При просрочке в разработке Программного обеспечении и/или выполнения иных Работ по настоящему Договору Заказчик вправе требовать от Исполнителя уплаты неустойки из расчёта 0,05 (Ноль целых пять сотых) процента от суммы аванса, уплаченного Заказчиком по настоящему Договору.\n6.3. Исполнитель не несет ответственности за любые убытки, возникшие в связи со сбоями и ошибками в функционировании Программного обеспечения, за исключением реального ущерба, причиненного Заказчику в связи с несвоевременным исполнением Исполнителем обязательств по гарантийной технической поддержке в гарантийный период.\n6.4. В иных случаях ответственность Сторон определяется действующим законодательством Российской Федерации.\n6.5. Ни одна из Сторон не несёт ответственности за просрочку в исполнении своих обязательств, если такая просрочка вызвана действиями или бездействием другой Стороны.\n6.6. Сторона, допустившая просрочку исполнения своих обязательств по настоящему Договору, освобождается от ответственности если докажет, что просрочка в исполнении обязательств явилась следствием действия обстоятельств непреодолимой силы (форс-мажорных обстоятельств). Под обстоятельствами непреодолимой силы Стороны подразумевают любые события, находящиеся вне контроля соответствующей Стороны и объективно препятствующие выполнению её обязательств по настоящему Договору, о возможности наступления которых просрочившая сторона не могла разумно предполагать при заключении настоящего Договора, в том числе включая, но не ограничиваясь: пожары, землетрясения, стихийные бедствия, военные действии, забастовки, гражданские волнения, аварии на линиях электроснабжения и связи.\n 7 Иные условия\nvar срок_уведомления_при_смене_реквизитов = 5 рабочих дней var срок_ответа_на_претензию = 5 рабочих дней  7.1. Настоящий Договор вступает в силу со дня его подписания обеими Сторонами и действует до полного исполнения ими обязательств из него вытекающих.\n7.2. Настоящий Договор, включая Приложение 1 составлен в 2 (Двух) подлинных экземплярах на _ (_****) страницах – по одному для каждой из Сторон.\n7.3. Любая из Сторон, в случае смены реквизитов, указанных в настоящем Договоре обязана не позднее 5 (Пяти) рабочих дней после смены реквизитов письменно уведомить об этом другую Сторону.\n7.4. Любые разногласия, вытекающие из настоящего Договора, Стороны договорились разрешать в досудебном претензионном порядке. Сторона, получившая письменную претензию, обязана не позднее 5 (Пяти) рабочих дней с момента получения такой претензии устранить указанные в ней нарушения, либо направить другой Стороне письменный мотивированный отказ в удовлетворении претензии.\n7.5. В случае если Сторонам не будет достигнуто согласие в досудебном порядке, спор подлежит передаче на рассмотрение Арбитражного суда Новосибирской области в порядке, определяемом законодательством Российской Федерации.\n 8 Реквизиты и подписи сторон.\nИсполнитель:\nЗаказчик:\nДиректор\n"},{"url":"https://d0sl.org/ru/d0sl-language/var/","title":"Переменные","description":"","content":"Вы можете использовать локальные переменные внутри блока check all, введя ключевое слово var.\nСуществуют важные ограничения на использование переменных. Во-первых, вы не можете изменить их значение после того, как оно было вычислено. Во-вторых, при каждом вызове предиката значение локальной переменной вычисляется только один раз. То есть, если вы используете ссылку на переменную несколько раз в предикате, ее значение будет вычислено только при первом использовании\n Пример # Testing for sin \u0026amp; cos def test() means  check all  var angle = 35  var cosinus = Math.cos(angle)  var sinus = Math.sin(angle)  var sum of squares = Math.pow(cosinus, 2) + Math.pow(sinus, 2)   # considering the features of the library java.lang.Math  # and inaccurate calculations when converting degrees to radians  sum of squares \u0026lt;= 1  sum of squares \u0026gt;= 0.999999  end end def "},{"url":"https://d0sl.org/ru/d0sl-language/domain/","title":"Модель предметной области","description":"","content":"Объекты предметной области (домена) Внутри доменной модели можно создавать типы, используя ключевое слово type, а затем использовать объекты этого типа в аргументах доменных функций и семантических предикатов.\nДоменная функция Внутри доменной модели можно определить доменные функции с помощью ключевого слова fun, а затем использовать эти функции в семантических предикатах.\n"},{"url":"https://d0sl.org/ru/d0sl-language/use/","title":"Use","description":"","content":"В семантической модели оператор use позволяет вам включать другие семантические модели и модели домена. Это означает, что если вы включили другую семантическую модель через оператор use, вы можете вызывать ее предикаты. Аналогично это работает и с доменной моделью.\nНапример, ниже мы включили доменную модель AutodromeDSL:\nuse AutodromeDSL from org.d0sl.examples.auto.AutodromeDSL После этого мы можем вызывать доменные функции, определенные в AutodromeDSL, в нашей семантической модели следующим образом:\ndef can stop2(car : Car) means  check all  not AutodromeDSL.wall ahead(car)  not AutodromeDSL.road sign(car)  AutodromeDSL.car ahead(car)  end end def  Вы можете указать класс реализации для доменной модели в поле from (для семантической модели это не обязательно). Класс реализации нужно указывать только в том случае, если вы хотите запустить модель внутри проекта MPS.\n Если вы указали класс реализации, он должен быть доступен через зависимости в вашем MPS-проекте. Реализация может быть добавлена либо через jar-файл, либо реализована непосредственно в MPS в отдельном решении, как это реализовано для примеров Chess и Autodrome.\n "},{"url":"https://d0sl.org/ru/d0sl-language/editor/","title":"Подсказки по редактору","description":"","content":"   Alias Эффект     Ctrl+space Автодополнение кода   Alt+enter Intentions меню   Ctrl+w Выделить сущность   def Определение предиката   use Ключевое слово use   check Ключевое слово Check all   and, or, not Логические операции   \u0026quot; \u0026ldquo;\u0026rdquo;, строковое значение   for Ключевое слово For all   if Конструкция if   Insert, enter Вставить аргумент в предикат или функцию   var Локальная переменная/константа (внутри check-all)   fun Заголовок функции в Domain Model   typedef Тип в Domain Model    "},{"url":"https://d0sl.org/ru/d0sl-language/run/","title":"Как запустить модель из MPS","description":"","content":" Если вы определите предикат start() без параметров в вашей семантической модели, он будет вызываться автоматически при запуске модели через контекстное меню в проекте MPS.\n Например, следующий предикат start() в примере про автодром сначала устанавливает препятствия и дорожные знаки на поле автодрома, а затем запускает графический интерфейс пользователя, вызывая другую доменную функцию start.\ndef start() means  check all  # set walls  AutodromeDSL.add wall(5, 1)  AutodromeDSL.add wall(5, 14)  AutodromeDSL.add wall(10, 8)  # set road signs  AutodromeDSL.add road sign(4, 5, \u0026#34;south\u0026#34;)  AutodromeDSL.add road sign(6, 9, \u0026#34;north\u0026#34;)  AutodromeDSL.add road sign(7, 7, \u0026#34;east\u0026#34;)   AutodromeDSL.start(10, 500)  end end def "},{"url":"https://d0sl.org/ru/","title":"d0sl semantic platform","description":"","content":""},{"url":"https://d0sl.org/ru/getting-started/","title":"Начало работы","description":"Запустите подготовленные примеры, чтобы быстро освоить Семантическую Платформу d0sl.","content":"В этой главе описывается процесс установки d0sl SDK и запуск демонстрационных примеров. Программисты также смогут узнать о том, как d0sl связывает логику и программный код.\n"},{"url":"https://d0sl.org/ru/vision/","title":"Видение","description":"Алгоритмы против логики. Или почему все люди понимают логику, но лишь малая часть из них умеет программировать.","content":"Алгоритмы против логики Книга правил дорожного движения содержит логические правила, регулирующие поведение автомобилей и людей на дорогах. Такой свод правил дорожного движения не очень толстый, может быть около ста страниц или около того. Предположим, вы переходите дорогу. Используя логику из книги правил дорожного движения, вы вырабатываете точный алгоритм, как вам поступить в данной конкретной ситуации.\nПредставьте себе, если бы все возможные ситуации на всех возможных перекрестках были описаны в книге правил дорожного движения? Сколько страниц должна содержать такая книга правил дорожного движения?) Это был бы алгоритмический подход.\nНо для правил дорожного движения мы используем логику, а не алгоритмы. Потому что логика позволяет представить знания в более компактной форме. В принципе, небольшой набор логических правил позволяет описать очень большое или даже бесконечное множество ситуаций.\n"},{"url":"https://d0sl.org/ru/d0sl-language/","title":"Язык спецификаций d0sl","description":"Узнайте подробнее о языке d0sl","content":" d0sl - это семантический язык для записи логических правил (или предикатов). d0sl разработан как максимально простой, но достаточный для записи всех логических операций, в соответствии с математической теорией семантического моделирования. d0sl может быть легко расширен функциями и объектами, специфичными для конкретной области. Таким образом, d0sl сам по себе является DSL (domain specific language). Для d0sl предусмотрен механизм расширения на уровне языка. Другими словами, для конкретных применений возможно строить иерархии DSL языков, которые преобразуются в d0sl и могут исполняться интерпертатором d0sl.  "},{"url":"https://d0sl.org/ru/math-foundation/","title":"Математика","description":"d0sl основан на разработках математиков из Новосибирского Академгородка, одного из крупнейших научных центров России.","content":"Первоначально математическая теория, лежащая в основе этой технологии, была разработана в Математическом институте имени Соболева тремя известными математиками Ю.Л. Ершовым, С.С. Гончаровым и Д.И. Свириденко.\nИтак, идея семантического моделирования заключается в том, как упростить общение с компьютером для непрограммистов. Вместо того, чтобы создавать еще один алгоритмический язык для программирования, семантическое моделирование фокусируется на использовании логического языка, позволяющего непрограммистам эффективно объяснять компьютерам что делать (в отличие от алгоритмов, описывающих как). Такие семантические модели называются исполняемыми спецификациями.\nd0sl означает Delta*0 (*дельта-ноль_)Semantiс Language.\n d0sl - это декларативный исполняемый язык спецификаций, который является конструктивным подмножеством языка логики предикатов первого порядка. Синтаксис d0sl здесь   Если вас более подробно интересует математическая теория, пожалуйста, ознакомьтесь с этим Список статей\n"},{"url":"https://d0sl.org/ru/contact/","title":" Напишите нам","description":"this is meta description","content":""},{"url":"https://d0sl.org/ru/categories/","title":"Categories","description":"","content":""},{"url":"https://d0sl.org/ru/search/","title":"Search Result","description":"this is meta description","content":""},{"url":"https://d0sl.org/ru/tags/","title":"Tags","description":"","content":""}]